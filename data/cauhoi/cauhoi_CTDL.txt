100
1|Cau truc du lieu la gi?|Tap hop cac cau truc|Ly thuyet khong can thiet|Cau truc luu tru va to chuc du lieu|Khong dap an|C
2|Cau nao sau day la CTDL tuyen tinh?|Danh sach lien ket|Cay nhi phan|Do thi|Heap|A
3|Do phuc tap thoi gian O(n) nghia la?|Thoi gian ty le theo cap so nhan|Thoi gian ty le voi kich thuoc input|Thoi gian khong doi|Khong dap an|B
4|Stack hoat dong theo phuong thuc nao?|FIFO|LIFO|Random|Priority|B
5|Queue hoat dong theo phuong thuc nao?|LIFO|FIFO|LILO|FIFI|B
6|Cau nao la loi ich cua danh sach lien ket?|Truy cap chi so O(1)|Chen va xoa nhanh o giua|Can bo nho lien tuc|Khong the duyet tu trai sang phai|B
7|Heap la cau truc du lieu gi?|Dang cay dung de tao priority queue|Danh sach lien ket dac biet|Do thi co huong|Mang mot chieu|A
8|Hash table chuc nang chinh la gi?|Luu tru doi tuong theo thu tu|Nhan dang va lay thong tin nhanh bang khoa|Thuc hien sap xep|Mo ta cay|B
9|Traversal inorder cua cay nhi phan la thu tu nao?|Root-Left-Right|Left-Root-Right|Left-Right-Root|Right-Left-Root|B
10|Traversal preorder la thu tu nao?|Left-Root-Right|Root-Left-Right|Left-Right-Root|Right-Left-Root|B
11|Traversal postorder la thu tu nao?|Left-Right-Root|Root-Left-Right|Left-Root-Right|Right-Left-Root|A
12|Which structure is best for LIFO operations?|Queue|Stack|Tree|Graph|B
13|Which structure is best for FIFO operations?|Stack|Queue|Heap|HashTable|B
14|Binary search tree property?|Left <= node < Right|Left < node < Right|Left > node|No order|B
15|Balanced tree reduces what?|Memory usage|Time complexity height to O(log n)|Number of nodes|Number of edges|B
16|Which sort uses divide and conquer?|Insertion sort|Merge sort|Bubble sort|Selection sort|B
17|Which is not comparison sort?|Merge sort|Counting sort|Quick sort|Heap sort|B
18|Graph can be represented by?|Adjacency matrix|Adjacency list|Edge list|All above|D
19|Dijkstra's algorithm finds?|Minimum spanning tree|Shortest path from source to all|Topological order|Sorting|B
20|Which is a spanning tree algorithm?|Dijkstra|Kruskal|BFS|Binary Search|B
21|Which uses LIFO to check balanced parentheses?|Queue|Stack|Hash table|Tree|B
22|Amortized cost of dynamic array append?|O(n)|O(1)|O(log n)|O(n log n)|B
23|Which is true about linked list?|Contiguous memory|Non-contiguous nodes with pointers|Fixed size|Sorted only|B
24|Which sort is worst-case O(n^2) but average O(n log n)?|Merge sort|Quick sort|Heap sort|Counting sort|B
25|Complexity of binary search on sorted array?|O(n)|O(log n)|O(n log n)|O(1)|B
26|AVL tree is type of?|Self-balancing BST|Heap|Hash table|Graph|A
27|Red-Black tree ensures?|Strict balance|Height O(log n)|No duplicates|O(1) insert|B
28|Which is used for LRU cache implementation commonly?|Stack|Queue|Doubly linked list + hashmap|Binary tree|C
29|What does 'push' on stack do?|Remove element|Add element to top|Add element to bottom|Peek element|B
30|What does 'pop' on stack do?|Add element|Remove top element|Sort elements|Check empty|B
31|Which is best for priority scheduling?|Stack|Heap|Queue|Linked list|B
32|Which traversal gives sorted order in BST?|Preorder|Inorder|Postorder|Level order|B
33|Which is true for array access?|O(n) access by index|O(1) access by index|No random access|Only sequential|B
34|Which is disadvantage of array?|Fixed size once allocated|Dynamic growth without realloc|Slow index access|High pointer overhead|A
35|Which is advantage of linked list over array?|Random access|Lower memory per element|Easier insertion/deletion in middle|Contiguous memory|C
36|Which is true for hash collisions?|Never happen|Handled by chaining or open addressing|Cause program crash|Prevented by BST|B
37|Which is used to detect cycles in graph?|Dijkstra|Floyd|DFS with visited|Kruskal|C
38|Topological sort applies to which graphs?|Undirected|Directed Acyclic Graphs|Cyclic directed|Weighted graphs|B
39|Which algorithm finds MST?|Dijkstra|Kruskal|Bellman-Ford|DFS|B
40|Which structure supports efficient insert at end?|Array with realloc|Linked list tail pointer|Binary tree|Hash table|B
41|BFS explores graph by?|Depth first|Breadth first|Random|Priority order|B
42|DFS uses which data structure?|Queue|Stack (implicit or explicit)|Heap|Hash set|B
43|Which is not a tree property?|Connected and acyclic|Exactly one path between nodes|Has cycles|Has root|C
44|Which is a complete binary tree?|All levels full except possibly last, left-filled|All nodes have two children|No null children allowed|Only root|A
45|Which sort is stable?|Quick sort (typical)|Merge sort|Heap sort|Selection sort|B
46|Which algorithm uses partitioning?|Merge sort|Quick sort|Insertion sort|Selection sort|B
47|Which is used to implement recursive function call stack?|Queue|Stack|Heap|Tree|B
48|Which data structure for undo feature?|Queue|Stack|Tree|Graph|B
49|Which is characteristic of doubly linked list?|Nodes have two pointers (prev, next)|Only next pointer|Contiguous memory|No pointers|A
50|Which is false about binary heap?|Complete binary tree|Heap property parent >= children (max-heap)|Used for priority queue|Has random access by key|D
51|Which algorithm finds shortest path with negative edges allowed?|Dijkstra|Bellman-Ford|Kruskal|Prim|B
52|Which of these sorts in-place?|Merge sort|Quick sort|Counting sort|Radix sort|B
53|Which is external sorting useful for?|Small data fits in memory|Large data on disk|Sorting linked list only|Sorting graphs|B
54|Which structure best for adjacency of sparse graph?|Adjacency matrix|Adjacency list|Edge list as array|Heap|B
55|Which is BFS applications?|Shortest path in unweighted graph|Sorting numbers|Balancing tree|Hashing|A
56|Which of these is not traversal order?|Inorder|Preorder|Postorder|Outorder|D
57|Which supports constant-time push/pop from both ends?|Array|Deque|Stack|Binary tree|B
58|Which is used to implement recursion?|Heap|Stack|Queue|Linked list|B
59|Which is dynamic array advantage?|Fixed size|Amortized O(1) append|No reallocations ever|O(n^2) access|B
60|Which finds connected components in undirected graph?|DFS|Dijkstra|Kruskal|Prim|A
61|Which data structure best for undo-redo with middle access?|Array|Doubly linked list|Stack only|Queue|B
62|Which is not a property of hash functions?|Deterministic mapping|Uniform distribution|Cryptographic strength always|Fast to compute|C
63|Which technique reduces complexity by reusing computations?|Greedy|Dynamic programming|Divide and conquer|Backtracking|B
64|Which algorithmic paradigm uses recursion and combine step?|Divide and conquer|Greedy|DP|Brute force|A
65|Which structure for implementing open addressing?|Hash table with probe sequences|Binary tree|Linked list|Priority queue|A
66|Which is used to detect cycle in directed graph?|Kahn's algorithm|DFS with recursion stack|Union-Find|All of above|B
67|Union-Find data structure used in which algorithm?|Dijkstra|Kruskal|Bellman-Ford|Floyd-Warshall|B
68|Which is NP problem example?|Sorting|Primality testing|Traveling Salesman (decision)|Binary search|C
69|Which method sorts by repeatedly swapping adjacent out-of-order elements?|Bubble sort|Merge sort|Quick sort|Heap sort|A
70|Which sort selects minimum and places at start?|Selection sort|Insertion sort|Merge sort|Bubble sort|A
71|Which algorithm maintains sorted prefix?|Insertion sort|Heap sort|Counting sort|Radix sort|A
72|Which is best-case O(n) sorting?|Bubble sort|Quick sort|Merge sort|Insertion sort (on nearly sorted)|D
73|Which is stable and linear for small k range?|Counting sort|Quick sort|Heap sort|Merge sort|A
74|Which data structure for implementing adjacency matrix?|2D array|Linked list|Hash table|Tree|A
75|Which is advantage of adjacency list over matrix for sparse graph?|Less memory|Faster edge existence check always|Simpler to implement|Supports weighted edges only|A
76|Which search guarantees shortest path in unweighted graph?|BFS|DFS|Dijkstra|A*|A
77|Which is used for topological sorting?|DFS or Kahn's algorithm|Dijkstra|Bellman-Ford|Prim|A
78|Which provides O(1) average access?|Hash table|Binary search tree|Linked list|Queue|A
79|Which uses rolling hash in string search?|KMP|Rabin-Karp|Boyer-Moore|Aho-Corasick|B
80|Which algorithm finds longest common prefix efficiently?|Brute force|Suffix array/lcp|Bubble sort|Quick sort|B
81|Which tree is perfect if all internal nodes have two children and leaves same depth?|Complete tree|Full tree|Perfect binary tree|Skewed tree|C
82|Which structure avoids rehashing by resizing?|Dynamic array underlying hash|Fixed hash table|Tree map|Skip list|A
83|Which is true for skip lists?|Deterministic|Probabilistic structure with levels|get O(log n) average|Both B and C|D
84|Which is used for range queries and updates?|Segment tree|Hash table|Array|Queue|A
85|Fenwick tree (BIT) used for?|Prefix sums and updates|Sorting|Graph traversal|Hashing|A
86|Which algorithm finds articulation points?|Tarjan's algorithm|Dijkstra|Kruskal|Prim|A
87|Which solves single-source shortest path in weighted graph without negative edges?|Dijkstra|Bellman-Ford|Floyd-Warshall|Kruskal|A
88|Which algorithm finds strongly connected components?|Kosaraju or Tarjan|Dijkstra|Prim|Kahn|A
89|Which is characteristic of a DAG?|Has cycles|No cycles and directional edges|Undirected edges only|All nodes same degree|B
90|Which returns elements in level order for tree?|Preorder|Inorder|Postorder|Breadth-first traversal|D
91|Which is used in Huffman coding?|Priority queue (heap)|Stack|Queue|Hash table|A
92|Which data structure used in A* search to pick next node?|Priority queue|Stack|Queue|Linked list|A
93|Which sorts nearly sorted array best?|Heap sort|Insertion sort|Bubble sort|Selection sort|B
94|Which structure for implementing undo stack with redo?|Two stacks|Queue and stack|Linked list only|Array only|A
95|Which is used for concurrency-safe append?|Locking around vector|Lock-free queue|Global interpreter lock|All of above|D
96|Which is used to implement associative array in C++ STL?|vector|map/unordered_map|list|set|B
97|Which uses hashing with balanced trees in buckets (C++17)?|unordered_map|map|unordered_map with node-based|unordered_map with buckets using trees|D
98|Which data structure supports get-min in O(1) and insert in O(log n)?|Stack|Min-heap|Queue|Hash map|B
99|Which allows amortized O(1) time for push and pop back?|std::vector|std::list|std::deque|std::set|A
100|Which ensures unique keys if used as map key?|unordered_map allows duplicates|map enforces unique keys|vector enforces unique|list enforces unique|B
3
1|Cau truc du lieu la gi?|Tap hop cac cau truc|Ly thuyet khong can thiet|Cau truc luu tru va to chuc du lieu|Khong dap an|C
2|Cau nao sau day la CTDL tuyen tinh?|Danh sach lien ket|Cay nhi phan|Do thi|Heap|A
3|Do phuc tap thoi gian O(n) nghia la?|Thoi gian ty le theo cap so nhan|Thoi gian ty le voi kich thuoc input|Thoi gian khong doi|Khong dap an|B
